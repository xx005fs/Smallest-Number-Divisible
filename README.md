# Smallest-Number-Divisible
  A small Java programme that you can use to input a number, and then you will get the smallest integer that is divisible by all the positive integers less than your input number.
# Introduction
  This year, I enrolled 2 classes involving computer science and programming: Functional and Object Oriented Programming. There are really a lot of interesting problems and projects that I can spend time on and making it exceed the teacher’s requirement. I am also taking a course learning how machine learning and AI works, there are also numerous questions that I can try to solve.
  
  Now it is finally summer, and school has ended, I finally have time to sum up the interesting projects that I have done over the past year, as well as making the project better than before. In this case, the goal of this problem is to find the smallest number that is divisible by all integers from 1 to 20. After I achieved the goal, I decided to take it a step further by calculating any number that is divisible by all positive integers that are less than or equal to the input number. There are in total of 2 methods made by me currently, one of the methods is significantly faster and more versatile than the other one. 
# Method 1
  1. This method uses Greatest Common Factors and Least Common Multiples to determine when in the series of numbers has to be simplified down.
  2. For example, when the input number of the function is 6, it is going to try to find the smallest possible number that can be divisible by all integers from 1-6.
    -The most straightforward way of finding a number that is divisible by all numbers from 1-6, you find the factorial of 6, and you get 720.
    -However, this is not the smallest number possible. For a number to be divisible by 6, it has to be divisible by both 3 and 2. In this case, 720 is in fact divisible by both 3 and 2, hence the 6 should not have been multiplied, and instead we would get the number 120.
    -Even though we reduced the size of the number by 1/6, it is still not the smallest possible number that satisfies the requirement. You realized that for the number to be divided by 4 it needs to be divisible by 2 twice. The number had been multiplied by 2 three times already (the 6 is already removed in this case), which means that one of the 2 is redundant. Thus, you divide the 2 out of the number 120, then you get the number 60. You realize you do indeed get the smallest number that satisfies the requirement as the rest of the numbers are either 1, prime or has to be included to make it satisfy the rule.
  3. This method has really good speed with numbers less than 20, however, when it exceeds 20, the speed slows down drastically due to the amount of loops that needs to be completed drastically increased, thus significantly reducing the sped. 
    -Using the tool nanoTime() in java, we could use it to precisely measure how long does this specific operation take for the computer to finish it.
    -In this case, when the number 23 is used as input, the computer running an Intel Core i7 3537U at 2893MHz took an insane 10080549 microseconds to complete, which is around 10.08 seconds total. With numbers bigger than 25 it would be practically impossible for the computer to be able to calculate this certain number. This is also the biggest flaw to this specific algorithm as it can’t be versatile enough to be able to calculate any number you throw at it at sufficient speeds.
    -However, it is relatively efficient with inputs less than 15. In this case using the input 14, it only took 11105 microseconds to complete, which is around 0.011 seconds to complete on the exact system.
# Method 2
  1. This methods starts by finding the pattern on which numbers needs to be simplified down yet still make the final number satisfies the result. 
  For example, let’s still use the number 6 as the input parameter. In all these 6 numbers excluding 1, there are 3 prime numbers and 2 composite numbers. The 3 prime numbers being 2, 3, and 5 and the 2 composites being 4 and 6. 
  Take the number 4 for example, at the beginning, the series of numbers have already being multiplied to 2 once, which means 2 only need to be multiplied another time rather than twice (2x2). There is a helper method present in this mini programme called primeExp() that does this exact operation. When the smallest 2 factors of the number can be divisible by each other, this means that the smallest factor had already being multiplied once, and thus it only had to be multiplied by another time. The helper method determines this by looking at if this number is a prime number to the power of n. If it is, it only had to be multiplied with the smallest factor since a prime number would have been previously used to be multiplied into the result already. Another special number in this example is 6, which is a composite number that is not an integer exponent of a certain number. Whenever the last 2 factors can’t be divided to get an integer, the number will be determined as a composite and not some number’s integer exponent. This helper method would know that both of the factor of the number had been used to multiply the result already, and thus it doesn’t need to multiply this number at all.
  This method drastically simplifies the operation as the programme doesn’t need to do the resource intensive finding of Greatest Common Factor (gcf()) over and over again compared to the slower method, as well as implementing an operation that directly determines if the number being multiplied into the final result would be prime as the findFactors() method isn’t resource intensive, and it wouldn’t make the programme enter the loop of primeExp() at all, which saves a lot of resources as that is the most resource intensive method in this faster method of solving because the number is predetermined to be prime and have to be multiplied into the final result.
  Using the same input number 23 as the previous example, the same computer only took 302 microseconds to complete the operation, which is a lot faster than the first one.
  Even with numbers as big as 700, with the output being 3.474*10^303, it still only took 6132 microseconds to complete the operation, and the input number can’t go higher as it is hitting the limit of how large the double data type could represent and output.
  However, I still tried it with input number of 20000, and the output just says infinity and the operation still took less time than the slow method with the input number of 23!
  This just shows the significance of the efficiency of a certain algorithm as it can drastically impact performance.
# Other useful informations
  Upon coding the small programme, I noticed that sometimes when you put in a number that is way too big, the size limitation of the Integer data type really changes the final result of the calculation.
  For the helper method lcm(), the calculation was written as this: “num1 * num2 / gcf” I realised that whenever the input numbers get too big, it exceeds the size limit of the Integer data type. When I input the number 20, using the lcm method the output is different than the method which uses patterns. This tells me that the precision of the number is not enough, so later I decided to change everything into the Double data type, which resolved the issue. 
  However, changed the data type to double isn’t the best way to fix this problem. Instead of changing the data type, I decided to divide a number with the gcf first and then multiply it as that doesn’t need the computer to round it after multiplication, then divides it, which leads to inaccurate results. Thus, I changed the code from num1 * num2 / gcf, which does all the operation in order, to num1 * (num2 / gcf), which does the division first and then multiplies it to get the final result, thus resolving the issue.
  Out of practicality, there is really no point using the double datatype for this operation as it has a really difficult time handling input number that is greater than 25, which can be represented by long instead of double, or just divide it first then multiplies it solves the issue as well. However, I still decided to use double for all the data types as the faster method shares some of the same helper methods that might skew the faster method’s result.
  The small programme could still be improved, and to do that I need to figure out a way to output a number greater than the size limit of the Double data type. If that is achievable, then in a relatively short period of time the programme would output any number that you put in that is less than 50000 as numbers above that are completely pointless and it will take an extremely long time to calculate it and output it as a result.
